low bit-rate compress of facial image
# 人脸图片压缩
证件照图片
特点：正脸，背景占小部分

# 算法步骤
核心算法：affine wrap，tree-kmeans，vq，
- **分层**
金字塔算法
-  **聚类 - 得到 VQ 字典**
将图片分成 8x8 的小块，每个块与块之间重叠 1 个像素重叠一个像素，在恢复的时候重叠部分取平均值
对于训练集中的每张图片都分块，对同一个位置的块采用 tree-kmeans 算法进行聚类，得到 2<sup>k</sup> 个向量，k 为表示这个块所需要的 bit 位数，**对于每个块，根据这个块的重要程度选择 k 的个数**（通过什么指标来衡量块的重要程度？MSE），如果分成 n 个块，就有 n 个 VQ 字典

- **编码 - 压缩图像**
  - 校准图片
通过 脸部的13 个特征点将图片划分成一系列三角形块，通过仿射函数，将图片与标准图片对齐
  - 编码
将对齐后的图片分割成 8x8 小块的集合，对于每个块，通过距离最近原则（MSE）从它对应的 VQ 字典中选择一个向量来表示，记录索引号（由于每个 VQ 字典中的向量个数是知道的，因此对于每个向量的表示只需要使用 k 个 bit，由于分块是按照顺序划分的，因此用于表示每个小块的 bit 可以直接连接在一起，组成一个比特流，用于表示图片

- **解码 - 解析比特流**
由第一个块开始，从对应的字典中 获得 k 的值假设为 4，从 bit 流的开头取出连续的 4 个 bit 还原成索引，然后根据索引从字典中取出向量，就完成了还原过程，接下来还原第二个块，从第二个块对应的字典中获取 k的值，假设为2，从第 5 个 bit 开始，取出 2 个 bit 还原成索引，从字典中取出向量还原

# 存在问题
- 存在表示误差过大，导致图片失真的情况
